---
description: 문자열 T에서 문자열 P가 있는지 찾는 알고리즘
---

# KMP\(Knuth–Morris–Pratt\)

## 설명

```text
문자열 T = A B A B B A B A B A B A
문자열 패턴 P = A B A B A 
```

위와 같은 예제에서 문자열 T에 문자열 P가 있는지 확인 하는 방법으로는   
P를 1칸씩 옮겨가며 꾸역꾸역 비교하는 방법이 있는데\(Brute-force 알고리즘\)  
이것의 시간 복잡도는 O\(t\*p\) 이다. -&gt; **터짐**

KMP알고리즘의 시간 복잡도는 O\(t+p\)인데 이것이 가능한 이유는   
1칸씩 옮겨가며 겹쳤던 부분의 정보를 이용하기 때문이다.

KMP알고리즘은 Pi 테이블이라는 패턴 P에 관한 정보표를 만들어야하는데  
P를 각 문자열 한 칸마다 접두사와 접미사로 나누어 겹치는 갯수를 담고있다.



근데 이 접두사와 접미사를 어떻게 활용 할 수 있을까?

| i | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| T | A | B | C | D | A | B | C | D | A | B |
| P | A | B | C | D | A | B | ~~E~~ | - | - | - |

위와 같은 예시를 보자!  
문자열 패턴 P의 앞의 6자리는 문자열 T와 일치했지만!  
아쉽게도 6번 인덱스와는 일치하지 않으므로 계속 탐색해야한다.

그럼 어떻게 다시 탐색 할까?



| i | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| T | A | B | C | D | A | B | C | D | A | B |
| P | - | ~~A~~ | ~~B~~ | ~~C~~ | ~~D~~ | ~~A~~ | ~~B~~ | ~~E~~ | - | - |

과거의 나였으면 분명 이따구로 완전 탐색을 돌리고 있었을 것이다.



| i | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| T | A | B | C | D | _**A**_ | _**B**_ | C | D | A | B |
| P | - | - | - | - | _**A**_ | _**B**_ | C | D | _**A**_ | _**B**_ |

접두사와 접미사를 통해 만든 Pi 테이블의 값을 통해 접미사 A, B가 일치했던 인덱스 4로 한번에 점프해서 확인 할 수 있다.  
또한 인덱스 4와 5는 이미 일치한 다는 것을 알고 있으므로   
최종적으로 6부터 확인을 진행하여 시간을 단축 시킬 수 있다.

## 코드

```cpp
vector<int> makeTable(string pattern){
	int patternSize = pattern.size();
	vector<int> table(patternSize, 0);
	int j =0;
	for(unsigned int i = 1; i< patternSize; i++){
		while(j >0 && pattern[i] != pattern[j]){
			j = table[j-1];
		}
		if(pattern[i] == pattern[j])
			table[i] =++j;
		}
	return table;
}
```

T에서 P를 1칸씩 옮겨가며 찾다가 만약 T!= P일 경우 1칸만 옮기는 것이 아니라 겹쳤던 부분만큼의 Pi테이블 정보 만큼 점프하기 때문에 O\(t+p\)가 가능하다.

-전체 코드는 지금 c++ 문법 몰라서 자꾸 틀려서 못올림-

참고 자료 : [http://bowbowbow.tistory.com/6](http://bowbowbow.tistory.com/6)

