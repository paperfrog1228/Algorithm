---
description: >-
  프로그래밍 대회에서 대부분의 사람이 가장 많이 하는 실수가 쉬운 문제를 어렵게 푸는 것이라고 한다. 그러나 난 항상 문제를 풀 때 무식하게
  먼저 풀려고 하는 습관이 있다. 그래서 정답률 개떨어진다. 그러나 말도 안되게 정작 브루트포스 문제는 잘 못 푼다.
---

# 6. 무식하게 풀기

## 재귀 호출\(Recursion\)

#### 재귀 함수\(Recursive function\)

자신이 수행할 작업을 유사한 형태의 여러 조각으로 쪼갠 뒤 그 중 한 조각을 수행하고, 나머지를 자기 자신에게 호출해 실행하는 함수.



#### 기저 사례\(Base case\)

재귀 함수는 '더 이상 쪼개지지 않는' 최소한의 작업에 도달했을 때 답을 곧장 반환하는 조건문을 포함하는데 이 때 '더 이상 쪼개지지 않는 가장 작은 작업'을 기저사례라 한다.



#### 예제: 중첩 반복문 대체하기

만약 내가 남들에게 재귀에 대한 수업을 진행한다면 이 예제가 적절한 사용 예시라 생각되어 적어놓는다.

아래는 0번부터 차례대로 번호가 매겨진 n개의 원소 중 세 개를 고르는 모든 경우를 출력하는 코드.

```cpp
for(int i=0;i<n;i++)
    for(int j=i+1;j<n;j++)
        for(int k=k+i;k<n;k++)
            printf("%d %d %d",i,j,k);
```

3개를 고르는 경우라 3중포문을 썼지만 문제에서 4개, 5개를 요구하면 위와 같이 코딩 시 4중, 5중 포문까지 구현해야한다. 코드가 더러워 질 뿐 아니라 유연한 코드라 볼 수 없다.

```cpp
void pick(int n, vector<int>& picked, int toPick){
    if(toPick == 0){ //이것이 기저 사례, 더 이상 고를 원소가 없을 때.
        대충 picked 출력한다는 코드.
        return; //중요
    }
    int smallest = picked.empty() ? 0 : picked.back()+1;
    for(int next = smallest;next<n;next++){
    picked.push_back(next);
    pick(n,picked,toPick-1);//재귀의 핵심
    picked.pop_back();
    }
}
```

종만북 종같아서 내가 알아서 코드좀 바꿨다. 여튼 이러면 코드도 유연하고 보기 좋다.

가장 큰 특징은 특정 조건을 만족하는 조합을 모두 생성하는 코드를 짤 수 있다는 것이다.

그래서 홍범이가 DFS 가르치기전에 재귀로 나를 그렇게 혹독하게..!



## 최적화 문제\(Optimization problem\)

문제의 답이 하나가 아니라 여러 개이고 그 중 어떤 기준에 따라 가장 좋은 답을 고르는 문제들.

이 장에서 설명하는 이유는 최적화 문제를 해결하기 위한 가장 직관적인 방법이 완전 탐색이기 때문.

### 외판원 순회 문제

[2098 : 외판원 순회](https://www.acmicpc.net/problem/2098) 를 대표적인 문제라고 소개하는데 책에는 n이 9라 완전 탐색만으로 풀었는지만 백준 문제는 n이 16이기 때문에 DFS만으로는 못 풀 것이다.

**Traveling Salesman problem \(TSP\)** 라고 컴퓨터 과학에서 자주 쓰이는 용어라는데 수업시간에 수업 안 들어서 모른다. 단어만 알아놓도록 하자.

## 많이 등장하는 완전 탐색 유형

### 모든 순열 만들기

주어진 원소의 모든 수열을 생성해서 풀 수 있는 문제는 꽤 자주 만날 수 있지만 N이 10이 넘어가면 거르자.

STL에 꿀 함수 next\_permutation\(\) 쓰면 생성해준다하니 알아두자.

### 모든 조합 만들기

### 2^n가지 경우의 수 만들기

