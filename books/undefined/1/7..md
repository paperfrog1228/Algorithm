# 7. 분할 정복

## 도입

각개 격파.

둘 이상의 부분 분제로 나눈 뒤 각 문제에 대한 답을 재귀를 이용하여 게산하고 전체 문제의 답을 계산해내는 것.

일반 재귀 호출과 다른 점은 문제를 한조각과 나머지 부분으로 나누는 대신 **같은 크기의 부분 문제**로 나누는 것.

* 문제를 더 작은 문제로 분할하는 과정\(divide\)
* 각 문제에 대해 구한 답을 원래 문제에 대한 답으로 병합하는 과정\(merge\)
* 더이상 답을 분할하지 않고 곧장 풀 수 있는 매우 작은 문제\(base case\)

대표적인 예제로는 '행렬의 거듭 제곱'이 있겠다.

## 나누어 떨어지지 않을 때의 분할과 시간 복잡도

$$A^7$$ 을 분할할 때 절반과 비슷한 $$A^3$$ \* $$A^4$$로 나누는 것이 베스트는 아니다.

pow 연산으로 예를 들어보자.

pow\(a,31\)은 pow\(a,15\)와 pow\(a,16\)으로 나누어지고

pow\(a,15\)는 또 다시 pow\(a,7\)와 pow\(a,8\)로

pow\(a,16\)은 pow\(a,8\)로 나누어진다.

그런데 여기서 pow\(a,8\)이 중복되게 되고 pow\(a,7\)로 나누어진 것 또한 중복 될 것이다.

그렇게에 31을 30과 1로 나누어 log연산으로 진행하는 방법이 시간 복잡도적으로 더욱 효율적인 것이다.

대표적인 예제로는 병합정렬과 퀵정렬이 있다.

두 정렬은 분할정복의 패러다임을 적용했으며 퀵 정렬은 분할하는 방법에 따라 시간 복잡도의 차이가 난다.

## 시간 복잡도 분석

병합 정렬의 경우 각 단계마다 반으로 나눈 부분 문제를 재귀를 이용하여 해결 한 뒤 이 수열을 합치는데,

반으로 나눌 때 거의 **항상 절반의 크기**로 나누기 때문에 O\(log n\) 만큼의 시간이, 그리고

정렬된 두 수열을 합할 때 각 수열의 길이만큼 반복문을 돌리기 때문에 O\(n\)만큼의 시간이 소요되므로

총 O\(n log n\)의 시간 복잡도가 소요된다.

퀵 정렬의 경우 대부분의 시간이 주어진 문제를 두 개의 부분으로 나누는 파티션 과정에서 소요된다.

파티션에는 수열의 길이에 비례하는 시간이걸리므로 병합 정렬의 병합 과정과 다를 것은 없다.

그러나 분할되는 두 부분이 비슷한 크기로 나눠진다는 보장은 없다.

최악의 경우에는 O\(n2\)라는 시간 복잡도를 가지게 된다.\(보통 대부분 O\(n log n\)임\)

그렇기에 퀵 정렬은 가능한 절반에 가까운 분할을 얻기 위해 다양한 방법을 적용한다.

## 카라츠바 알고리즘

내일 문제 풀어보고 읽어봄

188 페이지

